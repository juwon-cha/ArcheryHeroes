# 탑뷰 로그라이크 슈팅 게임 (궁수의 전설)

플레이 링크

https://khh7052.itch.io/archeryheroes

## 1. 프로젝트 개요

멈추면 자동으로 공격하고 움직여서 적의 공격을 피하며, 매번 새로운 능력을 조합해 스테이지를 돌파하는 로그라이크 액션 게임입니다.

개발 인원: 5명
<br>
개발 기간: 2025.07.29 - 2025.08.05
<br>
Unity Editor Version: 2022.3.17f1

<br>

## 2. 플레이 영상

<div align="center">
  <a href="https://www.youtube.com/watch?v=G0qNJMalqWA">
    <img src="https://img.youtube.com/vi/G0qNJMalqWA/maxresdefault.jpg" width="600" alt="첫 번째 유튜브 영상 썸네일">
  </a>
</div>

<br>

## 3. 주요 기능

-   **이동과 공격이 분리된 조작:** 플레이어는 이동에만 집중하며, 멈추면 가장 가까운 적을 향해 자동으로 공격합니다.
-   **로그라이크 능력 조합 시스템:** 레벨업 시 무작위로 제시되는 3가지 능력 중 하나를 선택하여, 매 플레이마다 다른 성장과 전투 경험을 제공합니다.
-   **랜덤 던전 생성:** 매 스테이지마다 일반, 이벤트, 보스 방이 무작위로 생성되어 반복 플레이의 재미를 더합니다.
-   **다양한 적과 보스 패턴:** 각기 다른 이동 및 공격 패턴을 가진 몬스터들과 FSM(상태 기계)을 통해 복합적인 행동을 하는 보스가 등장합니다.
-   **유연한 스탯 시스템:** 스크립터블 오브젝트를 활용하여 플레이어, 적, 무기 등의 데이터를 효율적으로 관리하고 쉽게 밸런싱할 수 있습니다.
-   **업적 및 미션 시스템:** 특정 조건을 달성하면 보상을 받는 업적 시스템이 구현되어 있습니다.

<br>

## 4. 프로젝트 전체 구조

프로젝트는 유니티의 표준 에셋 폴더 구조를 기반으로, 기능별로 명확하게 구분하는 구조를 따릅니다.

```
Assets/
├── 01.Scenes/          # 게임 씬 (시작, 메인, 플레이, 튜토리얼 등)
├── 02.Scripts/         # 모든 C# 스크립트
│   ├── Managers/     # 게임 전체를 관리하는 싱글톤 매니저 (GameManager, UIManager 등)
│   ├── Entity/       # 플레이어, 적 등 게임 내 개체의 핵심 로직
│   ├── AI/           # 적과 보스의 행동 로직 (FSM 상태 포함)
│   ├── Room/         # 던전 및 방 생성 관련 스크립트
│   ├── Ability/      # 능력 및 스킬 관련 로직
│   ├── UI/           # UI 요소 제어 스크립트
│   └── Common/       # 공용 시스템 (오브젝트 풀링, 속성 효과 등)
├── 03.Prefabs/         # 재사용 가능한 게임 오브젝트 (플레이어, 적, 방, UI 등)
├── 04.Animations/      # 애니메이션 컨트롤러 및 클립
├── 05.Textures/        # 텍스처 및 스프라이트 리소스
├── 06.Sounds/          # 사운드 클립 및 오디오 믹서
├── 07.Tilemap/         # 맵 제작에 사용되는 타일맵 리소스
├── 08.Input/           # 새로운 입력 시스템(New Input System) 액션 에셋
└── ScriptableObjects/  # 게임 데이터 에셋 (적 스탯, 능력 정보 등 - Prefabs/Data 폴더에 저장)
```

<br>

## 5. 기술적 의사결정 및 핵심 시스템 분석

이 프로젝트는 효율적이고 확장 가능한 구조를 만들기 위해 다음과 같은 핵심적인 기술과 디자인 패턴을 적용했습니다.

### 가. 랜덤 방 생성: DungeonManager 활용

-   **문제점:** 매번 똑같은 구조의 맵은 플레이를 단조롭게 만듭니다. 반복 플레이의 가치를 높이기 위해서는 예측할 수 없는 새로운 구조의 던전이 필요합니다.

-   **해결책:** `DungeonManager`를 통해 스테이지마다 다른 종류의 방을 랜덤하게 생성합니다.

-   **작동 방식:**
    1.  `DungeonManager`는 일반 방, 이벤트 방, 보스 방 프리팹 목록을 가지고 있습니다.
    2.  `LoadNextRoom` 메서드가 호출되면, 현재 스테이지 번호를 기준으로 방의 종류를 결정합니다.
        -   **보스 방:** 10의 배수 스테이지 (10, 20, ...)
        -   **이벤트 방:** 5의 배수 스테이지 (5, 15, ...)
        -   **일반 방:** 그 외 모든 스테이지
    3.  결정된 종류의 방 프리팹 중 하나를 무작위로 선택하여 `ObjectPoolingManager`를 통해 생성합니다.
    4.  이전 방이 있다면 풀에 반환하고, 플레이어의 위치를 새로 생성된 방의 시작 지점으로 이동시킵니다.

-   **결과:**
    -   **높은 재플레이성:** 플레이할 때마다 방의 순서와 종류가 달라져 새로운 경험을 제공합니다.
    -   **쉬운 확장:** 새로운 테마의 방이나 특별한 이벤트 방 프리팹을 만들어 목록에 추가하는 것만으로 쉽게 던전의 다양성을 높일 수 있습니다.

### 나. 보스 AI: 상태 패턴(State Pattern)을 이용한 FSM 구현

-   **문제점:** 보스는 플레이어와의 거리, 자신의 체력 등 다양한 조건에 따라 '추격', '원거리 공격', '특수 패턴', '대기' 등 여러 행동을 수행해야 합니다. 이를 하나의 스크립트에서 if-else나 switch로 관리하면 코드가 복잡해지고(스파게티 코드), 새로운 패턴을 추가하거나 수정하기 매우 어렵습니다.

-   **해결책:** 상태 패턴을 도입하여 보스의 각 행동을 `BossChaseState`, `BossAttackState` 와 같은 별개의 '상태' 클래스로 분리했습니다.

-   **결과:**
    -   **높은 확장성:** '광폭화' 같은 새로운 패턴을 추가하고 싶을 때, 새로운 상태 클래스만 만들어 추가하면 되므로 기존 코드에 미치는 영향이 최소화됩니다.
    -   **명확한 코드 구조:** 각 행동 로직이 해당 상태 클래스에 캡슐화되어 코드를 읽고 디버깅하기 매우 쉬워졌습니다.

### 다. 데이터 관리: 스크립터블 오브젝트 (Scriptable Object) 활용

-   **문제점:** 적의 체력/공격력, 아이템의 효과, 스킬의 데미지 같은 기획 데이터가 MonoBehaviour 스크립트 내부에 하드코딩되면, 값을 수정할 때마다 코드를 변경하고 프리팹을 일일이 수정해야 합니다. 이는 작업 효율을 떨어뜨리고, 밸런싱 작업을 어렵게 만듭니다.

-   **해결책:** 게임의 핵심 데이터를 스크립터블 오브젝트 에셋(`.asset` 파일)으로 분리하여 관리합니다.

-   **결과:**
    -   **메모리 효율화:** 100마리의 슬라임이 씬에 등장해도, 모든 슬라임은 단 하나의 '슬라임 데이터' 에셋을 공유하므로 메모리 사용량이 크게 감소합니다.
    -   **작업 효율 극대화:** 프로그래머가 아닌 기획자도 에디터에서 직접 데이터 에셋의 값을 수정하며 실시간으로 게임 밸런스를 테스트하고 조정할 수 있습니다.
    -   **코드와 데이터의 완벽한 분리:** 데이터 변경이 코드에 영향을 주지 않으므로 프로젝트가 안정적이고 유연해졌습니다.

### 라. 플레이어 입력: 새로운 입력 시스템 (New Input System)

-   **문제점:** 기존 `Input.GetKey()` 방식은 `Update()`에서 매 프레임 입력을 확인해야 하므로 비효율적이고, 키보드, 게임패드, 모바일 터치 등 다양한 플랫폼의 입력을 처리하기 위한 코드가 복잡해집니다.

-   **해결책:** 이벤트 기반의 New Input System을 사용합니다.

-   **결과:**
    -   **성능 향상:** 입력이 있을 때만 이벤트가 호출되므로 불필요한 `Update()` 체크가 사라집니다.
    -   **플랫폼 확장성:** 코드 수정 없이 새로운 입력 장치(예: 조이스틱)를 쉽게 추가할 수 있으며, 사용자가 직접 키를 변경하는 옵션도 간단하게 구현할 수 있습니다.

<br>

## 6. 프로젝트 작동 방식 (How It Works)

1.  **게임 시작:** `GameManager`가 게임에 필요한 요소(플레이어, UI, 매니저 등)를 초기화합니다.
2.  **던전 생성:** `DungeonManager`가 첫 번째 스테이지의 방을 생성하고 플레이어를 배치합니다.
3.  **플레이어 조작:** 사용자가 New Input System을 통해 캐릭터를 움직입니다.
4.  **전투 발생:** 플레이어가 움직임을 멈추면, `PlayerController`는 자동으로 가장 가까운 적을 탐지하고 `Projectile`을 발사합니다.
5.  **적 AI 행동:** 적들은 각자의 AI 패턴(단순 추적) 또는 보스의 FSM 상태에 따라 플레이어를 추격하거나 공격합니다.
6.  **레벨업과 능력 선택:** 적을 처치하여 경험치를 얻고 레벨업하면 게임이 일시 정지됩니다. `UIManager`가 3개의 무작위 **능력(`AbilitySO` 참조)**을 화면에 표시하고, 플레이어는 이 중 하나를 선택합니다.
7.  **스탯 적용:** 선택된 능력은 플레이어의 `StatHandler`에 반영되어 즉시 능력치가 강화됩니다.
8.  **스테이지 진행:** 현재 방의 모든 적을 처치하면 다음 방으로 이동할 수 있는 포탈이 열리고, `DungeonManager`가 다음 방을 로드합니다.
9.  **게임 오버/클리어:** 플레이어의 체력이 0이 되면 게임 오버, 최종 보스를 처치하면 게임 클리어 상태가 됩니다.
